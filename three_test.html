<!DOCTYPE html>
<html lang="en">
<head>
    <title>three.js webgl - instancing - performance</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        #info {
            background-color: rgba(0,0,0,0.75);
        }

        .lil-gui .gui-stats {
            line-height: var(--widget-height);
            padding: var(--padding);
        }

        .lil-gui .gui-selected {
            color: white;
        }
    </style>
</head>
<body>

<div id="info">

    <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - instancing - performance

</div>

<div id="container"></div>

<script type="module">
    import * as THREE from './build/three.module.js';

    import Stats from './libs/jsm/libs/stats.module.js';
    import { GUI } from './libs/jsm/libs/lil-gui.module.min.js';

    import { OrbitControls } from './libs/jsm/controls/OrbitControls.js';
    import { OBJLoader } from './libs/jsm/loaders/OBJLoader.js';

    let container, stats, gui, guiStatsEl, guiSelectedEl;
    let camera, controls, scene, renderer, material;
    let mesh, lastSelected;
    const color = new THREE.Color();

    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(1, 1);

    // gui

    const Method = {
        INSTANCED: 'INSTANCED',
        MERGED: 'MERGED',
        NAIVE: 'NAIVE'
    };

    const CLUSTER_COLORS = {
        0: 0x8CF5E5,
        1: 0x99D47D,
        2: 0xEBD686,
        3: 0xF0A27D,
        4: 0xF59FE8,
        5: 0x9696FA
    };

    // const api = {
    //     method: Method.INSTANCED,
    //     count: 1000
    // };

    //

    let data = [];

    init();
    initMesh();

    fetch('./results/prelim_data_5_cluster.json')
        .then(response => response.json())
        .then(json => {
        data = json
        initMesh();
    });

    animate();
    
    //

    function clean() {

        const meshes = [];


        scene.traverse( function ( object ) {

            if ( object.isMesh ) meshes.push( object );

        } );

        for ( let i = 0; i < meshes.length; i ++ ) {

            const mesh = meshes[ i ];
            mesh.material.dispose();
            mesh.geometry.dispose();

            scene.remove( mesh );

        }
    }

    const getMatrix = function () {

        const position = new THREE.Vector3();
        const rotation = new THREE.Euler();
        const quaternion = new THREE.Quaternion();
        const scale = new THREE.Vector3();
        let document = {};

        return function ( matrix, i ) {

            document = data[i];

            position.x = document.x * 20;
            position.y = document.y * 20 + 10;
            position.z = document.z * 20 + 10;

            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;
            // rotation.x = 0;
            // rotation.y = 0;
            // rotation.z = 0;

            quaternion.setFromEuler( rotation );

            scale.x = scale.y = scale.z = 0.01 * (0.8 + Math.random() * 0.4);

            matrix.compose( position, quaternion, scale );

        };

    }();

    function initMesh() {

        clean();

        // // make instances
        const loader = new OBJLoader();

        loader.load('./geometry/Sample_Book.obj', function ( object ) {

                    // console.log(object.children[0])
                    const geometry = object.children[0].geometry

                    material = new THREE.MeshLambertMaterial();

                    geometry.computeVertexNormals();

                    makeInstanced( geometry );

                })

    }


    function makeInstanced( geometry ) {

        const matrix = new THREE.Matrix4();
        mesh = new THREE.InstancedMesh( geometry, material, data.length );

        for ( let i = 0; i < data.length ; i ++ ) {

            getMatrix( matrix, i );
            mesh.setMatrixAt( i, matrix );

            console.log(data[i].cluster)
            mesh.setColorAt(i, color.setHex(CLUSTER_COLORS[data[i].cluster]));

        }

        scene.add( mesh );
    }

    function init() {

        const width = window.innerWidth;
        const height = window.innerHeight;

        // camera

        camera = new THREE.PerspectiveCamera( 70, width / height, 1, 100 );
        camera.position.z = 30;

        // renderer

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( width, height );
        renderer.outputEncoding = THREE.sRGBEncoding;

        container = document.getElementById( 'container' );
        container.appendChild( renderer.domElement );

        // scene

        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0x404040 );

        // controls

        controls = new OrbitControls( camera, renderer.domElement );
        controls.autoRotate = false;

        // lights

        const ambientLight = new THREE.AmbientLight(0x101010);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xfff3d4);
        scene.add(directionalLight)

        // const axes = new THREE.AxesHelper(20)
        // scene.add(axes)

        // stats

        stats = new Stats();
        container.appendChild( stats.dom );

        // gui

        gui = new GUI();
        // gui.add( api, 'method', Method ).onChange( initMesh );
        // gui.add( api, 'count', 1, 3000 ).step( 1 ).onChange( initMesh );

        // const perfFolder = gui.addFolder( 'Performance' );
        //
        // guiStatsEl = document.createElement( 'div' );
        // guiStatsEl.classList.add( 'gui-stats' );
        //
        // perfFolder.$children.appendChild( guiStatsEl );
        // perfFolder.open();

        const selectedFolder = gui.addFolder('Selected');

        guiSelectedEl = document.createElement( 'div' );
        guiSelectedEl.classList.add( 'gui-selected')

        selectedFolder.$children.appendChild(guiSelectedEl);
        selectedFolder.open();

        // listeners

        window.addEventListener( 'resize', onWindowResize );

        Object.assign( window, { scene } );

        document.addEventListener('mousemove', onMouseMove);
        document.addEventListener('mousedown', onMouseClick)
    }

    //

    function onWindowResize() {

        const width = window.innerWidth;
        const height = window.innerHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();

        renderer.setSize( width, height );

    }

    function onMouseMove( event ) {

        event.preventDefault();

        mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    }

    function onMouseClick( event ) {
        raycaster.setFromCamera(mouse, camera);

        const intersection = raycaster.intersectObject(mesh)
        if (intersection.length > 0) {
            if (lastSelected)
                mesh.setColorAt(lastSelected, color.setHex(CLUSTER_COLORS[data[lastSelected].cluster]));
            lastSelected = intersection[0].instanceId;
            mesh.setColorAt(lastSelected, color.setHex(0x0030ff));
            mesh.instanceColor.needsUpdate = true;
            // console.log(intersection[0].instanceId, data[intersection[0].instanceId]);

            guiSelectedEl.innerHTML = [

            '<i>Selected Title:</i>: ' + data[lastSelected].title

            ].join( '<br/>' );

        }
    }

    getNProximal(targetDoc, n=10);

    function animate() {

        requestAnimationFrame( animate );

        controls.update();
        stats.update();
        render();

    }

    function render() {

        renderer.render( scene, camera );

    }

    //

    function getGeometryByteLength( geometry ) {

        let total = 0;

        if ( geometry.index ) total += geometry.index.array.byteLength;

        for ( const name in geometry.attributes ) {

            total += geometry.attributes[ name ].array.byteLength;

        }

        return total;

    }

    // Source: https://stackoverflow.com/a/18650828/1314762
    function formatBytes( bytes, decimals ) {

        if ( bytes === 0 ) return '0 bytes';

        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = [ 'bytes', 'KB', 'MB' ];

        const i = Math.floor( Math.log( bytes ) / Math.log( k ) );

        return parseFloat( ( bytes / Math.pow( k, i ) ).toFixed( dm ) ) + ' ' + sizes[ i ];

    }

    
    function l2Distance(targetDoc) {

        dataDistances = JSON.parse(JSON.stringify(data)); //deep copy

        dataDistances.forEach(doc => {
            var xDif = targetDoc.x - doc['x'];
            var yDif = targetDoc.y - doc['y'];
            var zDif = targetDoc.z - doc['z'];
            if (targetDoc.document === doc.document){
                doc['distance'] = Number.MIN_VALUE;
            } else {
                doc['distance'] = Math.hypot(xDif, yDif, zDif); //returns sqrt(sum(x,y,z))
            }
        });


    }

    function getNProximal(targetDoc, n=10) {

        l2Distance(targetDoc); //get euclidean distance

        dataDistances.sort((i_1, i_2)=>
            i_1.distance - i_2.distance);

        const topN = dataDistances.slice(1,n+1); //ignore target element itself
        return topN;
        }

    function search(query) {
        var keywords = query.split(" ");

        var results = []
        data.forEach(element => {
            if (keywords.some(i => element.abstract.toLowerCase().includes(i))){
                results.push(element.document);
            }
        }); //ToDo: return some error message when no results were found
        return results;
    //ToDo: maybe use results with mesh.instanceColor.needsUpdate = true; to highlight/select result(s)
    }


</script>

</body>
</html>